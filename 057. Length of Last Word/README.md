当C++已经发展到11之际，各种处理字符串已经成了日常生活的一部分，遇到一道这样题，难免会感慨，擦，也太简单。

但要说三点：

1. 如何理解 "If the last word does not exist, return 0."， 测试用例： "a ", 应该返回多少？ 答案是1，因为即使最后一位是 `' '` ，但只要有 word 存在，那么 last word 就存在。

2. 用 `std::string` 或 `std::stringstream` 可不可以？我觉得没啥问题，有轮子不用什么意思？一个 `find_last_of(' ')``, 解决很多事。如果面试，可以跟面试官开玩笑的说，看他反应，如果他说不是考察你这个，那你老老实实用C的方法；如果笔试遇到，想都别想用这种偷懒的方式。

3. 我说用 C的方式，并不意味着用什么 `strlen` 之类的库函数，那还不如用上面的c++库，效率不一定差。

所以，最高效的方式一定要了解。完整的一次迭代逃不掉的，联系上述三点，你想想一个 `string::size()` 或 `strlen` 就已经耗尽一次迭代了。。

如何在这次迭代里就找到最后一个 word 的长度，很直接的办法就是一直记录每一个 word 的长度，再遇到新 word 的时候，重新记录。代码很简单：

```cpp
int len{0}; // 如果没有 word ，自然返回0
for (int beg = 0; *s, ++s) // 迭代
    if (*s == ' ') beg = 0; // 遇到空格，意味着重新记录
    else len = ++beg; // 不是空格，意味着累计长度
return len;
```

曾经说过，Easy 难度的题，至多五行，即使如此底层的代码依旧如此。我想这是在考验 C 基础。
