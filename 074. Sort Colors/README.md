这道题的解决思路，一定要看看我的commits log，太经典了。我感觉我的脑袋都进化了。

第一次，我觉得这道题忒简单，排什么序啊，总共才三个元素，迭代一次，纪录各个元素的个数，但后再来一次迭代，按顺序赋值即可。

于是有了[第一次提交](https://github.com/pezy/LeetCode/blob/9db17b692f6accb548634f9160a14d0bb2c68f39/25.%20Sort%20Colors/solution.h#L4-L15)。

然后我去打扫房间了。。。

期间我想，这么简单一道题，花了两次迭代，忒不值了吧。于是我觉得可以用交换来减少迭代次数。但无论如何，第一次迭代也要走完，否则怎么能知道到底有多少个0呢？第二次迭代可以从仅仅包含1和2的位置开始迭代即可。无论如何也是减少了迭代量。但这样代码看起来就没那么直观了。

于是有了[第二次提交](https://github.com/pezy/LeetCode/blob/ecc31ada47a85e1a9d52717abed27e660766e008/25.%20Sort%20Colors/solution.h#L6-L14)。

刚刚提交完，我觉得不服气啊，也没简化多少，让 @Mooophy 看到搞不好还要笑话我。于是我就开始考虑，能否在一次迭代就解决这件事。

思维开始走到牛角尖里去了，于是我放下，继续去干点家务。

脑子里再想到这道题的时候，发现有一个盲点我没发现：为什么不在迭代数组的时候同时修改数组呢？由于平时常用的是vector，迭代vector的时候明令禁止修改vector。所以竟然形成了思维惯性。此刻我们用的是纯数组，完全不需要考虑这么多。

我只需要设置两个flag，一个在头，一个在尾（尾巴都不用设，n是现成的啊）。然后用i去迭代，遇到等于0的，往头部交换，头flag++。遇到等于2的，往尾部交换，然后n--。但尾部交换完有个细节，就是i往后走，会略过这个刚交换完的值，所以我们交换的时候也要让i退一步。如此这般，待i全部走完，0全都在头，2全部在尾，中间就全是1了。

最后的解决方案，只有**三行**。有比这个更简洁的代码，一定要告诉我。
